# -*- coding: utf-8 -*-
"""IP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1530HArJw7CUR9NcD3JktxnifPj70RMBY
"""

from google.colab import drive
drive.mount('/content/gdrive')



!unzip "/content/gdrive/My Drive/Colab Notebooks/data.zip"

import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import tensorflow as tf

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        pass

!nvidia-smi

from tensorflow.keras.preprocessing.image import ImageDataGenerator

data_dir = 'images/'

datagen = ImageDataGenerator(rescale = 1./255, validation_split = 0.2)

train_data = datagen.flow_from_directory(data_dir, target_size = (250,250), batch_size = 32, class_mode = 'categorical',
                                        subset = 'training')

val_data = datagen.flow_from_directory(data_dir, target_size = (250,250), batch_size = 32, class_mode = 'categorical',
                                        subset = 'validation')

ResNet_V2_50 = 'https://tfhub.dev/google/imagenet/resnet_v2_50/classification/5'
Efficientnet_b0 = "https://tfhub.dev/google/efficientnet/b0/classification/1"

import tensorflow_hub as hub

model_ResNet = tf.keras.Sequential([
    hub.KerasLayer(ResNet_V2_50, trainable = False, input_shape = (250,250,3), name = 'Resnet_V2_50'),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(101, activation = 'softmax', name = 'Output_layer')
])

model_ResNet.compile(
    optimizer = tf.keras.optimizers.Adam(),
    loss = tf.keras.losses.CategoricalCrossentropy(),
    metrics = ['accuracy']
)

model_ResNet.summary()

tf.keras.utils.plot_model(model_ResNet)



resnet_model = model_ResNet.fit(train_data, epochs = 10, verbose = 1)

model_ResNet.evaluate(val_data)

from sklearn.metrics import classification_report

true_labels = val_data.classes

from sklearn.metrics import confusion_matrix
predicted_labels = np.argmax(model_ResNet.predict(val_data), axis=1)

cm = confusion_matrix(true_labels, predicted_labels)
print(cm[0].size)

cm_first_10 = cm[:10,:10]

plt.figure(figsize=(10,10))
plt.imshow(cm_first_10, interpolation='nearest', cmap=plt.cm.Blues)
plt.title('Restnet Confusion Matrix')
plt.colorbar()
tick_marks = np.arange(10)
plt.xticks(tick_marks, rotation=45)
plt.yticks(tick_marks)
plt.tight_layout()
plt.ylabel('True class labels')
plt.xlabel('Predicted class labels')

plt.show()

model_Efficientnet = tf.keras.Sequential([
    hub.KerasLayer(Efficientnet_b0, trainable = False, input_shape = (250,250,3), name = 'Efficientnet'),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(101, activation = 'softmax', name = 'Output_layer')
])

model_Efficientnet.compile(
    optimizer = tf.keras.optimizers.Adam(),
    loss = tf.keras.losses.CategoricalCrossentropy(),
    metrics = ['accuracy']
)

model_Efficientnet.summary()

tf.keras.utils.plot_model(model_Efficientnet)

efficientnet_model = model_Efficientnet.fit(train_data, epochs = 10, verbose = 1)

model_Efficientnet.evaluate(val_data)

predicted_labels_E = np.argmax(model_Efficientnet.predict(val_data), axis=1)

cme = confusion_matrix(true_labels, predicted_labels_E)
cme_first_10 = cm[:10,:10]
plt.figure(figsize=(10,10))
plt.imshow(cme_first_10, interpolation='nearest', cmap=plt.cm.Blues)
plt.title('Efficientnet Confusion Matrix')
plt.colorbar()
tick_marks = np.arange(10)
plt.xticks(tick_marks, rotation=45)
plt.yticks(tick_marks)
plt.tight_layout()
plt.ylabel('True class labels')
plt.xlabel('Predicted class labels')

plt.show()

def plot_graph(history, history_1):
    loss_res = history.history['loss']
    loss_ef = history_1.history['loss']
    
    Accuracy_res = history.history['accuracy']
    Accuracy_ef = history_1.history['accuracy']

    epochs = range(len(history.history['loss']))

    plt.plot(epochs, loss_res, label = 'ResNet Loss')
    plt.plot(epochs, loss_ef, label = 'Efficientnet Loss')
    plt.title('Epochs Vs Loss')
    plt.xlabel('epochs')
    plt.ylabel('Loss')
    plt.legend()

    plt.figure()
    plt.plot(epochs, Accuracy_res, label = 'ResNet Accuracy')
    plt.plot(epochs, Accuracy_ef, label = 'Efficientnet Accuracy')
    plt.title('Epochs Vs Accuracy')
    plt.xlabel('epochs')
    plt.ylabel('Accuracy')
    plt.legend()

plot_graph(resnet_model, efficientnet_model)

